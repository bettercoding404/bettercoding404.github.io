---
title:  C语言快速排序：原理、实现与最佳实践
description: ## 简介快速排序（Quick Sort）是由东尼·霍尔所发展的一种排序算法，在平均状况下，排序 \(n\) 个元素要 \(O(n \log n)\) 次比较。在最坏状况下则需要 \(O(n^2)\) 次比较，但这种情况并不常见。快速排序采用了分治法（Divide and Conquer）的思想，通过选择一个基准值（pivot），将数组分为两部分，小于基准值的元素放在左边，大于基准值的元素放在右边，然后递归地对左右两部分进行排序，最终得到一个有序数组。
date: 2025-01-16
categories: [c]
last_modified_at: 2025-04-05 
layout: post
cascade:
  - type: docs
---


## 简介
快速排序（Quick Sort）是由东尼·霍尔所发展的一种排序算法，在平均状况下，排序 \(n\) 个元素要 \(O(n \log n)\) 次比较。在最坏状况下则需要 \(O(n^2)\) 次比较，但这种情况并不常见。快速排序采用了分治法（Divide and Conquer）的思想，通过选择一个基准值（pivot），将数组分为两部分，小于基准值的元素放在左边，大于基准值的元素放在右边，然后递归地对左右两部分进行排序，最终得到一个有序数组。

## 目录
1. **基础概念**
    - **分治法思想**
    - **基准值选择**
    - **分区操作**
2. **使用方法**
    - **C语言代码实现**
    - **代码解释**
3. **常见实践**
    - **不同基准值选择策略**
    - **处理小数组**
4. **最佳实践**
    - **优化基准值选择**
    - **避免最坏情况**
    - **并行化快速排序**
5. **小结**

## 基础概念
### 分治法思想
分治法是一种解决问题的策略，它将一个大问题分解为若干个规模较小的子问题，分别解决这些子问题，然后将子问题的解合并起来得到原问题的解。在快速排序中，分治法的具体应用如下：
- **分解（Divide）**：选择一个基准值，将数组分为两部分，使得左边部分的元素都小于等于基准值，右边部分的元素都大于等于基准值。
- **解决（Conquer）**：递归地对左右两部分进行快速排序。
- **合并（Combine）**：由于左右两部分在递归排序后已经是有序的，不需要额外的合并操作，整个数组就已经有序。

### 基准值选择
基准值的选择对快速排序的性能有重要影响。常见的基准值选择方法有：
- **固定基准值**：选择数组的第一个元素、最后一个元素或中间元素作为基准值。这种方法简单，但在某些情况下可能导致最坏情况，例如数组已经有序时。
- **随机基准值**：随机选择数组中的一个元素作为基准值。这种方法可以有效避免最坏情况，但每次选择基准值都需要随机数生成，增加了一定的开销。
- **三数取中**：选择数组的第一个元素、最后一个元素和中间元素，取这三个元素的中间值作为基准值。这种方法在大多数情况下性能较好，并且不需要额外的随机数生成开销。

### 分区操作
分区操作是快速排序的核心步骤，它的目的是将数组分为两部分，使得左边部分的元素都小于等于基准值，右边部分的元素都大于等于基准值。常见的分区算法有：
- **单边循环法**：从数组的一端开始，遍历数组，将小于基准值的元素交换到左边，大于基准值的元素留在右边。
- **双边循环法**：从数组的两端开始，同时向中间遍历，将左边大于基准值的元素和右边小于基准值的元素进行交换，直到两个指针相遇。

## 使用方法
### C语言代码实现
下面是一个使用双边循环法实现的快速排序的C语言代码示例：

```c
#include <stdio.h>

// 交换两个整数的值
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 分区函数
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // 选择最后一个元素作为基准值
    int i = (low - 1);      // 小于基准值的元素的索引

    for (int j = low; j <= high - 1; j++) {
        // 如果当前元素小于等于基准值
        if (arr[j] <= pivot) {
            i++;  // 增大小于基准值的元素的索引
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

// 快速排序函数
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // 分区操作，返回基准值的索引
        int pi = partition(arr, low, high);

        // 递归地对左右两部分进行排序
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// 打印数组函数
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Original array: ");
    printArray(arr, n);

    quickSort(arr, 0, n - 1);

    printf("Sorted array: ");
    printArray(arr, n);

    return 0;
}
```

### 代码解释
1. **swap函数**：用于交换两个整数的值。
2. **partition函数**：实现了双边循环法的分区操作。选择数组的最后一个元素作为基准值，通过遍历数组，将小于等于基准值的元素交换到左边，大于基准值的元素交换到右边，最后返回基准值的索引。
3. **quickSort函数**：递归地对数组进行快速排序。如果 `low` 小于 `high`，则进行分区操作，然后递归地对左右两部分进行排序。
4. **printArray函数**：用于打印数组的元素。
5. **main函数**：定义了一个测试数组，并调用 `quickSort` 函数对其进行排序，最后打印排序前后的数组。

## 常见实践
### 不同基准值选择策略
如前文所述，基准值的选择对快速排序的性能有重要影响。在实际应用中，可以根据具体情况选择不同的基准值选择策略：
- **数据规模较小且分布均匀**：可以选择固定基准值，如第一个元素或中间元素，因为这种情况下简单的策略通常就可以取得较好的性能。
- **数据规模较大或可能出现有序数据**：随机基准值或三数取中策略可以有效避免最坏情况，提高算法的稳定性和性能。

### 处理小数组
对于小数组，快速排序的递归调用可能会带来额外的开销，导致性能下降。在这种情况下，可以采用插入排序等简单的排序算法来代替快速排序。一种常见的优化方法是设置一个阈值，当数组规模小于阈值时，使用插入排序，当数组规模大于阈值时，使用快速排序。

## 最佳实践
### 优化基准值选择
除了随机基准值和三数取中策略外，还可以采用更复杂的方法来选择基准值，如“五数取中”等策略。这些方法可以进一步提高基准值的代表性，减少最坏情况的发生。

### 避免最坏情况
除了选择合适的基准值外，还可以通过对输入数据进行预处理来避免最坏情况。例如，在排序之前对数据进行洗牌操作，打乱数据的顺序，使得数据更接近随机分布。

### 并行化快速排序
对于大规模数据，可以采用并行化的快速排序算法来提高排序效率。并行化快速排序利用多核处理器的优势，将排序任务分配到多个核心上并行执行，从而加快排序速度。

## 小结
快速排序是一种高效的排序算法，具有平均 \(O(n \log n)\) 的时间复杂度。通过理解其基础概念、掌握使用方法、了解常见实践和最佳实践，读者可以在C语言编程中灵活运用快速排序算法，提高程序的性能和效率。在实际应用中，需要根据具体问题和数据特点选择合适的基准值选择策略、处理小数组的方法以及优化措施，以达到最佳的排序效果。

希望这篇博客能帮助你深入理解并高效使用C语言快速排序。如果你有任何问题或建议，欢迎在评论区留言。